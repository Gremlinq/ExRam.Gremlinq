<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="..\T4\Constants.tt" #>
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
using System;
using System.Linq.Expressions;
using System.Collections.Generic;
using Gremlin.Net.Process.Traversal;

namespace ExRam.Gremlinq.Core
{
    partial interface IGremlinQuery
    {
<# for(var i = 2; i <= 16; i++) { #>
        IGremlinQuery<(<#= GetArgumentList("T{0}", i) #>)> Select<<#= GetArgumentList("T{0}", i) #>>(<#= GetArgumentList("StepLabel<T{0}> label{0}", i) #>);
<# } #>
    }

<# foreach(var iface in baseInterfaces) { #>

    public partial interface <#= iface #>
    {
        <#= iface #> And(params Func<<#= iface #>, IGremlinQuery>[] andTraversals);

        new <#= iface #> Barrier();

        TTargetQuery Choose<TTargetQuery>(Func<<#= iface #>, IGremlinQuery> traversalPredicate, Func<<#= iface #>, TTargetQuery> trueChoice, Func<<#= iface #>, TTargetQuery> falseChoice) where TTargetQuery : IGremlinQuery;
        TTargetQuery Choose<TTargetQuery>(Func<<#= iface #>, IGremlinQuery> traversalPredicate, Func<<#= iface #>, TTargetQuery> trueChoice) where TTargetQuery : IGremlinQuery;

        new TTargetQuery Choose<TTargetQuery>(Func<IChooseBuilder<<#= iface #>>, IChooseBuilderWithCaseOrDefault<TTargetQuery>> continuation) where TTargetQuery : IGremlinQuery;

        TTargetQuery Coalesce<TTargetQuery>(params Func<<#= iface #>, TTargetQuery>[] traversals) where TTargetQuery : IGremlinQuery;

        new <#= iface #> Dedup();
        new <#= iface #> Drop();

        new <#= iface #> Emit();

        TTargetQuery FlatMap<TTargetQuery>(Func<<#= iface #>, TTargetQuery> mapping) where TTargetQuery : IGremlinQuery;

        new IGremlinQuery<IDictionary<TNewKey, TNewValue>> Group<TNewKey, TNewValue>(Func<IGroupBuilder<<#= iface #>>, IGroupBuilderWithKeyAndValue<<#= iface #>, TNewKey, TNewValue>> groupBuilder);
        new IGremlinQuery<IDictionary<TNewKey, object>> Group<TNewKey>(Func<IGroupBuilder<<#= iface #>>, IGroupBuilderWithKey<<#= iface #>, TNewKey>> groupBuilder);

        new <#= iface #> Identity();

        new <#= iface #> Limit(long count);
        new <#= iface #> LimitLocal(long count);
        TTargetQuery Local<TTargetQuery>(Func<<#= iface #> , TTargetQuery> localTraversal) where TTargetQuery : IGremlinQuery;

        TTargetQuery Map<TTargetQuery>(Func<<#= iface #>, TTargetQuery> mapping) where TTargetQuery : IGremlinQuery;
        
        <#= iface #> Not(Func<<#= iface #>, IGremlinQuery> notTraversal);
        new <#= iface #> None();

        <#= iface #> Optional(Func<<#= iface #>, <#= iface #>> optionalTraversal);
        <#= iface #> Or(params Func<<#= iface #>, IGremlinQuery>[] orTraversals);

        new <#= iface #> Range(long low, long high);

        <#= iface #> Repeat(Func<<#= iface #>, <#= iface #>> repeatTraversal);
        <#= iface #> RepeatUntil(Func<<#= iface #>, <#= iface #>> repeatTraversal, Func<<#= iface #>, IGremlinQuery> untilTraversal);
        <#= iface #> UntilRepeat(Func<<#= iface #>, <#= iface #>> repeatTraversal, Func<<#= iface #>, IGremlinQuery> untilTraversal);

        <#= iface #> SideEffect(Func<<#= iface #>, IGremlinQuery> sideEffectTraversal);
        new <#= iface #> Skip(long count);

        new <#= iface #> Tail(long count);
        new <#= iface #> TailLocal(int count);

        new <#= iface #> Times(int count);

        TTargetQuery Union<TTargetQuery>(params Func<<#= iface #>, TTargetQuery>[] unionTraversals) where TTargetQuery : IGremlinQuery;

        new <#= iface #> Where(ILambda lambda);
    }
<# } #>


<# foreach(var iface in Untyped(baseInterfaces)) { #>
    public partial interface <#= iface #>
    {
        new <#= iface + "<TResult>" #> Cast<TResult>();
        new IGremlinQuery<dynamic> Project(Func<IProjectBuilder<<#= iface #><object>, object>, IProjectResult> continuation);
        new IGremlinQuery<TResult> Project<TResult>(Func<IProjectBuilder<<#= iface #><object>, object>, IProjectResult<TResult>> continuation);
    }
<# } #>


<# foreach(var iface in Typed(baseInterfaces)) { #>
    public partial interface <#= iface #>
    {
        new IGremlinQuery<dynamic> Project(Func<IProjectBuilder<<#= iface #>, <#= GetElement(iface) #>>, IProjectResult> continuation);
        new IGremlinQuery<TResult> Project<TResult>(Func<IProjectBuilder<<#= iface #>, <#= GetElement(iface) #>>, IProjectResult<TResult>> continuation);
    }
<# } #>


<# foreach(var iface in Typed(Qualified(baseInterfaces))) { #>
    public partial interface <#= iface #>
    {
        new <#= iface #> Order(Func<IOrderBuilder<<#= GetElement(iface) #>, <#= iface #>>, IOrderBuilderWithBy<<#= GetElement(iface) #>, <#= iface #>>> projection);
    }
<# } #>


<# foreach(var iface in Untyped(Qualified(baseInterfaces))) { #>
    public partial interface <#= iface #>
    {
        new <#= iface #> Order(Func<IOrderBuilder<<#= iface #>>, IOrderBuilderWithBy<<#= iface #>>> projection);
    }
<# } #>


<# foreach(var iface in Typed(Simple(Element(baseInterfaces)))) { #>
    public partial interface <#= iface #>
    {
<# if (!iface.Contains("VertexProperty")) { #>
        new IValueGremlinQuery<IDictionary<string, TTarget>> ValueMap<TTarget>(params Expression<Func<<#= GetElement(iface) #>, TTarget>>[] keys);
<# } #>

        new IValueGremlinQuery<TTarget> Values<TTarget>(); 
        new IValueGremlinQuery<TTarget> Values<TTarget>(params Expression<Func<<#= GetElement(iface) #>, TTarget>>[] projections);
        new IValueGremlinQuery<TTarget> Values<TTarget>(params Expression<Func<<#= GetElement(iface) #>, TTarget[]>>[] projections);
    }
<# } #>


<# foreach(var iface in Untyped(baseInterfaces)) { #>
    public partial interface <#= iface #>
    {
        new <#= iface #><TTarget> OfType<TTarget>();
    }
<# } #>
    

<# foreach(var iface in Typed(Qualified(Element(baseInterfaces)))) { #>
    public partial interface <#= iface #>
    {
<# if (!iface.Contains("VertexProperty")) { #>
        new <#= iface #> Update(<#= GetElement(iface) #> element);
        new <#= iface.Replace(GetElement(iface), "TTarget") #> OfType<TTarget>();
        new <#= iface #> Property<TProjectedValue>(Expression<Func<<#= GetElement(iface) #>, TProjectedValue>> projection, TProjectedValue value);

<# if (iface.StartsWith("IVertexGremlinQuery")) { #>
        new <#= iface #> Property<TProjectedValue>(Expression<Func<<#= GetElement(iface) #>, TProjectedValue[]>> projection, TProjectedValue value);
<# } #>

<# } #>

new <#= iface #> Property(string key, object value);
new <#= iface #> Where(Expression<Func<<#= GetElement(iface) #>, bool>> predicate);
new <#= iface #> Where<TProjection>(Expression<Func<<#= GetElement(iface) #>, TProjection>> projection, Func<IGremlinQuery<TProjection>, IGremlinQuery> propertyTraversal);
    }
<# } #>

<# foreach(var iface in Typed(baseInterfaces)) { #>
    public partial interface <#= iface #>
    {
        TTargetQuery Aggregate<TTargetQuery>(Func<<#= iface #>, StepLabel<<#= iface #>, <#= GetElement(iface) #>>, TTargetQuery> continuation) where TTargetQuery : IGremlinQuery;
        TTargetQuery As<TTargetQuery>(Func<<#= iface #>, StepLabel<<#= iface #>, <#= GetElement(iface) #>>, TTargetQuery> continuation) where TTargetQuery : IGremlinQuery;

        new <#= iface.Replace(GetElement(iface), "TResult") #> Cast<TResult>();
        new <#= iface #> Coin(double probability);

        new IArrayGremlinQuery<<#= GetElement(iface) #>[], <#= iface #>> Fold();
    }
<# } #>

<# foreach(var iface in baseInterfaces) { #>
    public partial interface <#= iface #>
    {
        new <#= iface #> Where(Func<<#= iface #>, IGremlinQuery> filterTraversal);
    }
<# } #>

<# for(var i = 2; i <= 16; i++) { #>
public interface IProjectTupleBuilder<out TSourceQuery, TElement, <#= GetArgumentList("TItem{0}", i) #>> : IProjectResult<(<#= GetArgumentList("TItem{0}", i) #>)>
        where TSourceQuery : IGremlinQuery
    {
    <# if (i < 16) { #>
        IProjectTupleBuilder<TSourceQuery, TElement, <#= GetArgumentList("TItem{0}", i + 1) #>> By<TItem<#= i + 1 #>>(Func<TSourceQuery, IGremlinQuery<TItem<#= i + 1 #>>> projection);
    <# } #>
    }
<# } #>

}

#pragma warning restore CS0109 // Member does not hide an inherited member; new keyword is not required
<#@ include file="..\T4\HelperMethods.tt" #>